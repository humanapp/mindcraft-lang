import { Dict } from "../../platform/dict";
import { Error } from "../../platform/error";
import { List, type ReadonlyList } from "../../platform/list";
import { StringUtils as SU } from "../../platform/string";
import { UniqueSet } from "../../platform/uniqueset";
import {
  type BrainProgram,
  BYTECODE_VERSION,
  type FunctionBytecode,
  type HostCallSiteEntry,
  type IBrainDef,
  type IBrainPageDef,
  type IBrainRuleDef,
  type Instr,
  type ITileCatalog,
  NIL_VALUE,
  Op,
  type PageMetadata,
  type TileId,
  TRUE_VALUE,
  Value,
} from "../interfaces";
import { ConstantPool } from "./constant-pool";
import { BytecodeEmitter } from "./emitter";
import { computeExpectedTypes } from "./expected-types";
import { computeInferredTypes } from "./inferred-types";
import { parseBrainTiles } from "./parser";
import { type CompilationDiag, ExprCompiler } from "./rule-compiler";
import type { ActuatorExpr, Expr, SensorExpr, TypeEnv, TypeInfo } from "./types";
import { acceptExprVisitor } from "./types";

/**
 * Replace all "/" characters with "_" (for function naming)
 */
function replaceAllSlashes(str: string): string {
  let result = "";
  const len = SU.length(str);
  for (let i = 0; i < len; i++) {
    const charCode = SU.charCodeAt(str, i);
    // "/" is ASCII 47
    result += charCode === 47 ? "_" : SU.fromCharCode(charCode);
  }
  return result;
}

/**
 * Recursively walk an Expr tree to collect sensor and actuator tile IDs.
 */
function collectTileIds(expr: Expr, sensors: UniqueSet<TileId>, actuators: UniqueSet<TileId>): void {
  switch (expr.kind) {
    case "sensor": {
      sensors.add(expr.tileDef.tileId);
      collectSlotExprs(expr, sensors, actuators);
      break;
    }
    case "actuator": {
      actuators.add(expr.tileDef.tileId);
      collectSlotExprs(expr, sensors, actuators);
      break;
    }
    case "binaryOp":
      collectTileIds(expr.left, sensors, actuators);
      collectTileIds(expr.right, sensors, actuators);
      break;
    case "unaryOp":
      collectTileIds(expr.operand, sensors, actuators);
      break;
    case "assignment":
      collectTileIds(expr.value, sensors, actuators);
      break;
    case "parameter":
      collectTileIds(expr.value, sensors, actuators);
      break;
    case "errorExpr":
      if (expr.expr) collectTileIds(expr.expr, sensors, actuators);
      break;
    case "literal":
    case "variable":
    case "modifier":
    case "empty":
      break;
  }
}

/**
 * Collect tile IDs from the slot expressions (anons, parameters, modifiers)
 * of a sensor or actuator expression.
 */
function collectSlotExprs(
  expr: SensorExpr | ActuatorExpr,
  sensors: UniqueSet<TileId>,
  actuators: UniqueSet<TileId>
): void {
  for (let i = 0; i < expr.anons.size(); i++) {
    collectTileIds(expr.anons.get(i)!.expr, sensors, actuators);
  }
  for (let i = 0; i < expr.parameters.size(); i++) {
    collectTileIds(expr.parameters.get(i)!.expr, sensors, actuators);
  }
  for (let i = 0; i < expr.modifiers.size(); i++) {
    collectTileIds(expr.modifiers.get(i)!.expr, sensors, actuators);
  }
}

/**
 * Result of compiling a single rule.
 */
interface RuleCompileResult {
  /** Generated bytecode for this rule */
  code: List<Instr>;

  /** Variable names used by this rule (for LOAD_VAR/STORE_VAR) */
  variableNames: ReadonlyList<string>;

  /** Function IDs of child rules that need to be CALLed */
  childFuncIds: List<number>;
}

/**
 * BrainCompiler compiles an entire Brain definition into a single BrainProgram.
 *
 * Architecture:
 * - Each rule becomes a single function in the program
 * - Functions are assigned IDs in depth-first traversal order
 * - Parent rules CALL their child rules after DO section completes
 * - All rules share a single constant pool
 * - Variables are resolved at Brain level (shared across all rules)
 *
 * Function layout:
 * ```
 * func[rule]:
 *   WHEN_START
 *   ... when bytecode ...
 *   WHEN_END              ; jumps to skip_label if false
 *   DO_START
 *   ... do bytecode ...
 *   DO_END
 *   CALL child_rule_0, 0  ; execute children in order
 *   CALL child_rule_1, 0
 *   ...
 * skip_label:
 *   RET
 * ```
 */
export class BrainCompiler {
  private constantPool: ConstantPool;
  private functions: List<FunctionBytecode>;
  private ruleIndex: Dict<string, number>;
  private pages: List<PageMetadata>;
  private nextFuncId: number;
  private catalogs: ReadonlyList<ITileCatalog>;
  /** Global variable name pool for LOAD_VAR/STORE_VAR instructions */
  private variableNames: List<string>;
  /** Maps variable names to their index in variableNames */
  private variableIndices: Dict<string, number>;
  /** Counter for unique call-site IDs (shared across all rules for uniqueness) */
  private nextCallSiteIdCounter: { value: number };

  constructor(catalogs: ReadonlyList<ITileCatalog>) {
    this.constantPool = new ConstantPool();
    this.functions = List.empty();
    this.ruleIndex = Dict.empty();
    this.pages = List.empty();
    this.nextFuncId = 0;
    this.catalogs = catalogs;
    this.variableNames = List.empty();
    this.variableIndices = Dict.empty();
    this.nextCallSiteIdCounter = { value: 1 };
  }

  /**
   * Compile an entire Brain definition into a single BrainProgram.
   *
   * @param brainDef - The brain definition to compile
   * @returns A complete BrainProgram ready for execution
   */
  compile(brainDef: IBrainDef): BrainProgram {
    // Reset state for fresh compilation
    this.constantPool = new ConstantPool();
    this.functions = List.empty();
    this.ruleIndex = Dict.empty();
    this.pages = List.empty();
    this.nextFuncId = 0;
    this.variableNames = List.empty();
    this.variableIndices = Dict.empty();
    this.nextCallSiteIdCounter = { value: 0 };

    // First pass: assign function IDs to all rules (depth-first)
    const pageList = brainDef.pages();
    for (let pageIdx = 0; pageIdx < pageList.size(); pageIdx++) {
      const pageDef = pageList.get(pageIdx);
      this.assignFuncIds(pageDef, pageIdx);
    }

    // Second pass: compile all rules with known function IDs
    for (let pageIdx = 0; pageIdx < pageList.size(); pageIdx++) {
      const pageDef = pageList.get(pageIdx);
      this.compilePage(pageDef, pageIdx);
    }

    return {
      version: BYTECODE_VERSION,
      functions: this.functions,
      constants: this.constantPool.getConstants(),
      variableNames: this.variableNames,
      entryPoint: 0, // First page's first rule
      ruleIndex: this.ruleIndex,
      pages: this.pages,
    };
  }

  /**
   * First pass: Assign function IDs to all rules in depth-first order. This
   * allows us to know child function IDs before compiling parents.
   */
  private assignFuncIds(pageDef: IBrainPageDef, pageIdx: number): void {
    const rootRuleFuncIds = List.empty<number>();
    const rules = pageDef.children();

    for (let ruleIdx = 0; ruleIdx < rules.size(); ruleIdx++) {
      const ruleDef = rules.get(ruleIdx);
      const funcId = this.assignFuncIdToRule(ruleDef, `${pageIdx}/${ruleIdx}`);
      rootRuleFuncIds.push(funcId);
    }

    this.pages.push({
      pageIndex: pageIdx,
      pageName: pageDef.name(),
      pageId: pageDef.pageId(),
      rootRuleFuncIds,
      hostCallSites: List.empty(),
      sensors: new UniqueSet(),
      actuators: new UniqueSet(),
    });
  }

  /**
   * Recursively assign function IDs to a rule and its children.
   */
  private assignFuncIdToRule(ruleDef: IBrainRuleDef, rulePath: string): number {
    const funcId = this.nextFuncId++;
    this.ruleIndex.set(rulePath, funcId);

    // Reserve slot in functions list (will be filled during compile pass)
    this.functions.push({
      code: List.empty(),
      numParams: 0,
      name: `rule_${replaceAllSlashes(rulePath)}`,
    });

    // Assign IDs to children
    const children = ruleDef.children();
    for (let childIdx = 0; childIdx < children.size(); childIdx++) {
      const childDef = children.get(childIdx);
      this.assignFuncIdToRule(childDef, `${rulePath}/${childIdx}`);
    }

    return funcId;
  }

  /**
   * Second pass: Compile all rules in a page, then collect host function IDs.
   */
  private compilePage(pageDef: IBrainPageDef, pageIdx: number): void {
    const rules = pageDef.children();
    const pageMetadata = this.pages.get(pageIdx)!;

    for (let ruleIdx = 0; ruleIdx < rules.size(); ruleIdx++) {
      const ruleDef = rules.get(ruleIdx);
      this.compileRule(ruleDef, `${pageIdx}/${ruleIdx}`, pageMetadata);
    }

    // Collect all host call sites from all compiled rules in this page
    const visitedFuncs = new UniqueSet<number>();
    this.collectHostCallSites(pageMetadata.rootRuleFuncIds, visitedFuncs, pageMetadata.hostCallSites);
  }

  /**
   * Recursively collect all HOST_CALL / HOST_CALL_ASYNC call sites from a set
   * of rule functions and their children (via CALL instructions). Each call
   * site is recorded with its fnId and callSiteId so that onPageEntered can be
   * invoked with the correct currentCallSiteId.
   */
  private collectHostCallSites(
    funcIds: List<number>,
    visitedFuncs: UniqueSet<number>,
    out: List<HostCallSiteEntry>
  ): void {
    for (let i = 0; i < funcIds.size(); i++) {
      const funcId = funcIds.get(i)!;
      if (visitedFuncs.has(funcId)) continue;
      visitedFuncs.add(funcId);

      const fn = this.functions.get(funcId);
      if (!fn) continue;

      const childFuncIds = List.empty<number>();
      for (let pc = 0; pc < fn.code.size(); pc++) {
        const ins = fn.code.get(pc)!;
        if (ins.op === Op.HOST_CALL || ins.op === Op.HOST_CALL_ASYNC) {
          out.push({ fnId: ins.a ?? 0, callSiteId: ins.c ?? 0 });
        } else if (ins.op === Op.CALL) {
          childFuncIds.push(ins.a ?? 0);
        }
      }

      // Recurse into child rules
      if (childFuncIds.size() > 0) {
        this.collectHostCallSites(childFuncIds, visitedFuncs, out);
      }
    }
  }

  /**
   * Compile a single rule and its children recursively.
   */
  private compileRule(ruleDef: IBrainRuleDef, rulePath: string, pageMetadata: PageMetadata): void {
    const funcId = this.ruleIndex.get(rulePath);
    if (funcId === undefined) {
      throw new Error(`BrainCompiler: No function ID assigned for rule at ${rulePath}`);
    }

    // Collect child function IDs
    const childFuncIds = List.empty<number>();
    const children = ruleDef.children();
    for (let childIdx = 0; childIdx < children.size(); childIdx++) {
      const childPath = `${rulePath}/${childIdx}`;
      const childFuncId = this.ruleIndex.get(childPath);
      if (childFuncId !== undefined) {
        childFuncIds.push(childFuncId);
      }
    }

    // Compile this rule's WHEN and DO
    const result = this.compileRuleBody(ruleDef, childFuncIds, pageMetadata);

    // Update the function in place
    const fn = this.functions.get(funcId)!;
    fn.code = result.code;

    // Recursively compile children
    for (let childIdx = 0; childIdx < children.size(); childIdx++) {
      const childDef = children.get(childIdx);
      this.compileRule(childDef, `${rulePath}/${childIdx}`, pageMetadata);
    }
  }

  /**
   * Compile a rule's WHEN/DO body and emit CALL instructions for children.
   */
  private compileRuleBody(
    ruleDef: IBrainRuleDef,
    childFuncIds: List<number>,
    pageMetadata: PageMetadata
  ): RuleCompileResult {
    const whenTiles = ruleDef.when().tiles();
    const doTiles = ruleDef.do().tiles();

    // Parse WHEN and DO sides
    const whenParseResult = parseBrainTiles(whenTiles, -1, 0);
    const doParseResult = parseBrainTiles(doTiles, -1, 0);

    // Collect sensor/actuator tile IDs from parsed expressions
    for (let i = 0; i < whenParseResult.exprs.size(); i++) {
      collectTileIds(whenParseResult.exprs.get(i), pageMetadata.sensors, pageMetadata.actuators);
    }
    for (let i = 0; i < doParseResult.exprs.size(); i++) {
      collectTileIds(doParseResult.exprs.get(i), pageMetadata.sensors, pageMetadata.actuators);
    }

    // Type checking
    const typeEnv: TypeEnv = new Dict<number, TypeInfo>();

    for (let i = 0; i < whenParseResult.exprs.size(); i++) {
      computeExpectedTypes(whenParseResult.exprs.get(i), typeEnv);
    }
    for (let i = 0; i < doParseResult.exprs.size(); i++) {
      computeExpectedTypes(doParseResult.exprs.get(i), typeEnv);
    }

    for (let i = 0; i < whenParseResult.exprs.size(); i++) {
      computeInferredTypes(whenParseResult.exprs.get(i), this.catalogs, typeEnv);
    }
    for (let i = 0; i < doParseResult.exprs.size(); i++) {
      computeInferredTypes(doParseResult.exprs.get(i), this.catalogs, typeEnv);
    }

    // Create emitter for this rule's function
    const emitter = new BytecodeEmitter();
    const endLabel = emitter.label();

    // Emit WHEN section
    emitter.whenStart();
    this.emitExprs(whenParseResult.exprs, emitter, typeEnv, true);
    emitter.whenEnd(endLabel);

    // Emit DO section
    emitter.doStart();
    this.emitExprs(doParseResult.exprs, emitter, typeEnv, false);
    emitter.doEnd();

    // Emit CALL for each child rule (only if WHEN was true, i.e., we're before endLabel)
    for (let i = 0; i < childFuncIds.size(); i++) {
      const childFuncId = childFuncIds.get(i)!;
      emitter.call(childFuncId, 0);
      // Pop the return value from child (children don't return meaningful values)
      emitter.pop();
    }

    // Mark end label (jumped to if WHEN was false - skips DO and children)
    emitter.mark(endLabel);

    // Push NIL as return value (RET expects a value on the stack)
    // Rule functions don't return meaningful values - caller always discards the result
    const nilIdx = this.constantPool.add(NIL_VALUE);
    emitter.pushConst(nilIdx);

    // Return
    emitter.ret();

    return {
      code: emitter.finalize(),
      variableNames: this.variableNames,
      childFuncIds,
    };
  }

  /**
   * Emit bytecode for a list of expressions. Uses the global variable pool for
   * all variable references.
   *
   * @param exprs - List of expressions to emit (always has at least one
   * element)
   * @param emitter - Bytecode emitter
   * @param typeEnv - Type environment
   * @param isWhenContext - If true, empty expressions push TRUE; if false, they
   * emit nothing
   */
  private emitExprs(
    exprs: ReadonlyList<Expr>,
    emitter: BytecodeEmitter,
    typeEnv: TypeEnv,
    isWhenContext: boolean
  ): void {
    const context = {
      variableIndices: this.variableIndices,
      variableNames: this.variableNames,
      typeEnv,
      constantPool: this.constantPool,
      nextCallSiteId: this.nextCallSiteIdCounter,
      diags: List.empty<CompilationDiag>(),
    };

    const compiler = new ExprCompiler(emitter, context);

    // Get the first expression (rest are errors/recovery)
    const expr = exprs.get(0);

    // Handle empty expressions based on context
    if (expr.kind === "empty") {
      if (isWhenContext) {
        // Empty WHEN means "always true" - push TRUE
        const trueIdx = this.constantPool.add(TRUE_VALUE);
        emitter.pushConst(trueIdx);
      }
      // Empty DO means "do nothing" - emit nothing
      return;
    }

    // Emit the expression
    acceptExprVisitor(expr, compiler);
  }
}

/**
 * Compile an entire brain definition into a single program. This is the main
 * entry point for whole-brain compilation.
 *
 * @param brainDef - The brain definition to compile
 * @param catalogs - Tile catalogs for type resolution
 * @returns A complete BrainProgram
 */
export function compileBrain(brainDef: IBrainDef, catalogs: ReadonlyList<ITileCatalog>): BrainProgram {
  const compiler = new BrainCompiler(catalogs);
  return compiler.compile(brainDef);
}
