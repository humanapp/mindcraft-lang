import { Dict } from "../../platform/dict";
import { Error } from "../../platform/error";
import { List } from "../../platform/list";
import { MathOps } from "../../platform/math";
import { EventEmitter, type EventEmitterConsumer } from "../../util";
import { compileBrain } from "../compiler";
import {
  type BrainEvents,
  type BrainProgram,
  type ExecutionContext,
  FiberState,
  HandleTable,
  type IBrain,
  type IBrainDef,
  type IBrainPageDef,
  type IBrainRule,
  type Value,
} from "../interfaces";
import { getBrainServices } from "../services";
import { BrainPage } from "./page";
import type { BrainRule } from "./rule";
import { FiberScheduler, VM } from "./vm";

/**
 * Brain runtime instance.
 *
 * The Brain serves as the central execution engine for all rules.
 * It owns a single VM and FiberScheduler that execute the compiled BrainProgram.
 *
 * Architecture: Each Rule = One Function
 * - The entire brain is compiled into a single BrainProgram
 * - Each rule becomes a function in the program
 * - The Brain owns one VM instance and one FiberScheduler
 * - Variables are stored at the Brain level (shared across all rules)
 * - Page switching spawns fibers for the new page's root rules
 *
 * Execution Model:
 * - On page activation, spawn fibers for each root rule in the page
 * - Each frame, tick the scheduler to execute fibers
 * - When a rule's WHEN is true, it executes DO and then CALLs child rules
 * - Fibers that complete are respawned on the next frame
 */
export class Brain implements IBrain {
  private readonly emitter_ = new EventEmitter<BrainEvents>();
  private enabled: boolean = true;
  private interrupted: boolean = false;
  private currentPageIndex: number = 0;
  private desiredPageIndex: number = 0;
  private restartPageRequested: boolean = false;
  private lastThinkTime: number = 0;

  /** Runtime page instances */
  pages: List<BrainPage> = new List<BrainPage>();

  /**
   * Variable storage at the Brain level.
   * Variables are keyed by their unique ID (not by name).
   * This is the default scope for all variables.
   */
  private readonly variables: Dict<string, Value> = new Dict<string, Value>();

  /**
   * Compiled program for the entire brain.
   * Generated by BrainCompiler from the brain definition.
   */
  private program: BrainProgram | undefined;

  /**
   * Single VM instance for executing all rules.
   */
  private vm: VM | undefined;

  /**
   * Single scheduler for managing all fibers.
   */
  private scheduler: FiberScheduler | undefined;

  /**
   * Handle table for async operations.
   */
  private handles: HandleTable;

  /**
   * Persistent execution context for the brain.
   * Shared across all fibers, provides variable access.
   */
  private executionContext: ExecutionContext | undefined;

  /**
   * Fiber IDs for the currently active page's root rules.
   * Tracked for respawning when they complete.
   */
  private activeRuleFiberIds: List<{ funcId: number; fiberId: number | undefined }> = List.empty();

  /** O(1) lookup from stable pageId (UUID) to page index, built during initialize(). */
  private pageIdToIndex: Dict<string, number> = new Dict();

  /** O(1) lookup from page name to page index, built during initialize(). */
  private pageNameToIndex: Dict<string, number> = new Dict();

  constructor(public readonly brainDef: IBrainDef) {
    this.handles = new HandleTable(100000);

    // Create runtime page instances
    brainDef.pages().forEach((pageDef: IBrainPageDef) => {
      const page = new BrainPage(this, pageDef);
      this.pages.push(page);
    });
  }

  events(): EventEmitterConsumer<BrainEvents> {
    return this.emitter_.consumer();
  }

  /**
   * Compile the brain and initialize the VM.
   * Must be called before think() can execute rules.
   */
  initialize(contextData?: unknown): void {
    // Compile the entire brain into a single program
    const catalogs = List.from([getBrainServices().tiles]);
    this.program = compileBrain(this.brainDef, catalogs);

    // Create VM with the compiled program
    this.vm = new VM(this.program, this.handles);

    // Create scheduler
    this.scheduler = new FiberScheduler(this.vm, {
      maxFibersPerTick: 64,
      defaultBudget: 1000,
      autoGcHandles: true,
    });

    // Assign function IDs to runtime rule objects and build funcId->rule mapping
    const funcIdToRule = new Dict<number, IBrainRule>();
    for (let pageIdx = 0; pageIdx < this.pages.size(); pageIdx++) {
      const page = this.pages.get(pageIdx)!;
      page.assignFuncIds(this.program.ruleIndex, pageIdx);
      this.collectFuncIdToRuleMapping(page.children(), funcIdToRule);
    }

    // Build page lookup indices for O(1) resolution in requestPageChangeByPageId / requestPageChangeByName
    this.pageIdToIndex = new Dict();
    this.pageNameToIndex = new Dict();
    for (let i = 0; i < this.program.pages.size(); i++) {
      const meta = this.program.pages.get(i);
      if (meta) {
        this.pageIdToIndex.set(meta.pageId, i);
        this.pageNameToIndex.set(meta.pageName, i);
      }
    }

    // Create shared execution context
    // Use a closure-based object to satisfy Roblox-TS method requirements
    const brain = this;
    this.executionContext = {
      brain: this,
      getVariable<T extends Value>(varId: string): T | undefined {
        return brain.getVariable<T>(varId);
      },
      setVariable(varId: string, value: Value): void {
        brain.setVariable(varId, value);
      },
      clearVariable(varId: string): void {
        brain.clearVariable(varId);
      },
      fiberId: -1,
      time: 0,
      dt: 0,
      currentTick: 0,
      funcIdToRule,
      data: contextData,
    };
  }

  /**
   * Check if the brain has been initialized and is ready to execute.
   */
  isInitialized(): boolean {
    return this.vm !== undefined && this.scheduler !== undefined && this.program !== undefined;
  }

  /**
   * Get the compiled program (for debugging/inspection).
   */
  getProgram(): BrainProgram | undefined {
    return this.program;
  }

  /**
   * Get a variable value by its unique ID.
   * @param varId - Unique identifier for the variable
   * @returns The variable's current value, or undefined if not found
   */
  getVariable<T extends Value>(varId: string): T | undefined {
    return this.variables.get(varId) as T | undefined;
  }

  /**
   * Set a variable value by its unique ID.
   * @param varId - Unique identifier for the variable
   * @param value - The value to store
   */
  setVariable(varId: string, value: Value): void {
    this.variables.set(varId, value);
  }

  /**
   * Clear a variable by its unique ID.
   * @param varId - Unique identifier for the variable
   */
  clearVariable(varId: string): void {
    this.variables.delete(varId);
  }

  /**
   * Clear all variables (useful for reset/cleanup).
   */
  clearVariables(): void {
    this.variables.clear();
  }

  setEnabled(enabled: boolean) {
    this.enabled = enabled;
  }

  isEnabled() {
    return this.enabled;
  }

  interrupt() {
    this.interrupted = true;
  }

  clearInterrupt() {
    this.interrupted = false;
  }

  isInterrupted() {
    return this.interrupted;
  }

  requestPageChange(pageIndex: number) {
    if (pageIndex < 0 || pageIndex >= this.pages.size()) {
      // Invalid page index -> disable the brain by setting desired page to -1
      this.desiredPageIndex = -1;
      return;
    }
    this.desiredPageIndex = pageIndex;
    // Cancel active fibers so no more rules evaluate this tick
    this.cancelActiveFibers();
  }

  requestPageChangeByPageId(pageId: string): void {
    const idx = this.pageIdToIndex.get(pageId);
    if (idx !== undefined) {
      this.requestPageChange(idx);
      return;
    }
    // No pageId match -- fall back to name lookup so that programmatically
    // constructed strings still work (e.g. page-jump tables).
    this.requestPageChangeByName(pageId);
  }

  requestPageChangeByName(name: string): void {
    const idx = this.pageNameToIndex.get(name);
    if (idx !== undefined) {
      this.requestPageChange(idx);
      return;
    }
    // No matching page found -> resolve to -1 (disabled)
    this.requestPageChange(-1);
  }

  requestPageRestart() {
    this.restartPageRequested = true;
    // Cancel active fibers so no more rules evaluate this tick
    this.cancelActiveFibers();
  }

  startup() {
    this.currentPageIndex = this.desiredPageIndex = 0;
    this.restartPageRequested = false;
    this.lastThinkTime = 0;
    this.interrupted = false;

    // Activate first page
    if (this.isInitialized() && this.pages.size() > 0) {
      this.activatePage(0);
    }
  }

  shutdown() {
    // Cancel all active fibers
    this.deactivateCurrentPage();

    // Clear handles
    this.handles.clear();

    // Clear variables
    this.clearVariables();
  }

  think(currentTime: number) {
    if (!this.enabled || this.interrupted || !this.pages.size() || !this.isInitialized()) return;

    // Handle page restart (same page, deactivate + reactivate)
    if (this.restartPageRequested) {
      this.restartPageRequested = false;
      if (this.isValidPageIndex(this.currentPageIndex)) {
        this.deactivateCurrentPage();
        this.activatePage(this.currentPageIndex);
      }
    }

    // Handle page changes
    if (this.currentPageIndex !== this.desiredPageIndex) {
      // Deactivate current page
      this.deactivateCurrentPage();

      this.currentPageIndex = this.desiredPageIndex;

      // Activate new page
      if (this.isValidPageIndex(this.currentPageIndex)) {
        this.activatePage(this.currentPageIndex);
      }
    }

    // Execute current page's rules
    if (this.isValidPageIndex(this.currentPageIndex)) {
      const dt = this.lastThinkTime === 0 ? 0 : currentTime - this.lastThinkTime;
      this.thinkPage(currentTime, dt);
    }

    this.lastThinkTime = currentTime;
  }

  rng(): number {
    return MathOps.random(); // TODO: Replace with a seeded deterministic RNG
  }

  /**
   * Activate a page by spawning fibers for its root rules.
   */
  private activatePage(pageIndex: number): void {
    if (!this.program || !this.scheduler || !this.executionContext) return;

    const pageMetadata = this.program.pages.get(pageIndex);
    if (!pageMetadata) return;

    // Clear any existing tracked fibers
    this.activeRuleFiberIds = List.empty();

    // Spawn a fiber for each root rule in the page
    for (let i = 0; i < pageMetadata.rootRuleFuncIds.size(); i++) {
      const funcId = pageMetadata.rootRuleFuncIds.get(i)!;
      const fiberId = this.scheduler.spawn(funcId, List.empty(), this.executionContext);
      this.activeRuleFiberIds.push({ funcId, fiberId });
    }

    // Notify host functions of page entry, once per call site
    const fns = getBrainServices().functions;
    for (let i = 0; i < pageMetadata.hostCallSites.size(); i++) {
      const site = pageMetadata.hostCallSites.get(i)!;
      const entry = fns.getSyncById(site.fnId) ?? fns.getAsyncById(site.fnId);
      if (entry?.fn.onPageEntered) {
        this.executionContext.currentCallSiteId = site.callSiteId;
        entry.fn.onPageEntered(this.executionContext);
      }
    }

    // Notify the page runtime
    const page = this.pages.get(pageIndex);
    if (page) {
      page.activate();
      this.emitter_.emit("page_activated", { pageIndex });
    }
  }

  /**
   * Cancel all active fibers for the current page.
   * Used to stop execution immediately when a page change or restart is requested.
   */
  private cancelActiveFibers(): void {
    if (!this.scheduler) return;
    for (let i = 0; i < this.activeRuleFiberIds.size(); i++) {
      const entry = this.activeRuleFiberIds.get(i)!;
      if (entry.fiberId !== undefined) {
        this.scheduler.cancel(entry.fiberId);
      }
    }
  }

  /**
   * Deactivate the current page by cancelling its fibers.
   */
  private deactivateCurrentPage(): void {
    this.cancelActiveFibers();
    this.activeRuleFiberIds = List.empty();

    // Notify the page runtime
    if (this.isValidPageIndex(this.currentPageIndex)) {
      const page = this.pages.get(this.currentPageIndex);
      if (page) {
        page.deactivate();
        this.emitter_.emit("page_deactivated", { pageIndex: this.currentPageIndex });
      }
    }
  }

  /**
   * Execute one frame of the current page's rules.
   */
  private thinkPage(currentTime: number, dt: number): void {
    if (!this.scheduler || !this.executionContext) return;

    // Update execution context
    this.executionContext.time = currentTime;
    this.executionContext.dt = dt;
    this.executionContext.currentTick += 1;

    // Check if any root rule fibers need respawning
    for (let i = 0; i < this.activeRuleFiberIds.size(); i++) {
      const entry = this.activeRuleFiberIds.get(i)!;
      const needsRespawn = this.shouldRespawnFiber(entry.fiberId);

      if (needsRespawn) {
        const newFiberId = this.scheduler.spawn(entry.funcId, List.empty(), this.executionContext);
        entry.fiberId = newFiberId;
      }
    }

    // Run the scheduler tick
    this.scheduler.tick();

    this.scheduler.gc();
  }

  /**
   * Check if a fiber needs to be respawned (completed, faulted, or cancelled).
   */
  private shouldRespawnFiber(fiberId: number | undefined): boolean {
    if (fiberId === undefined) return true;
    if (!this.scheduler) return false;

    const fiber = this.scheduler.getFiber(fiberId);
    if (!fiber) return true;

    return fiber.state === FiberState.DONE || fiber.state === FiberState.FAULT || fiber.state === FiberState.CANCELLED;
  }

  private isValidPageIndex(pageIndex: number): boolean {
    return pageIndex >= 0 && pageIndex < this.pages.size();
  }

  /**
   * Recursively collect funcId -> BrainRule mappings from rules and their children.
   */
  private collectFuncIdToRuleMapping(rules: List<BrainRule>, mapping: Dict<number, IBrainRule>): void {
    for (let i = 0; i < rules.size(); i++) {
      const rule = rules.get(i)!;
      const funcId = rule.getFuncId();
      if (funcId !== undefined) {
        mapping.set(funcId, rule);
      }
      this.collectFuncIdToRuleMapping(rule.children(), mapping);
    }
  }
}
